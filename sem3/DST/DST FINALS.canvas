{
	"nodes":[
		{"id":"228fcf71a9c61079","x":-460,"y":-80,"width":300,"height":240,"type":"text","text":"QB FINALS\n\nLegend:\ngreen - UNIT 1\nred - UNIT 2\nblue - UNIT 3\npurple - UNIT 4\norange - UNIT 5\nyellow - UNIT 6"},
		{"id":"f1fb50e6c00b4f01","x":-680,"y":500,"width":250,"height":50,"color":"4","type":"text","text":"UNIT 1"},
		{"id":"f85094ec76ee6ffb","x":-2000,"y":1700,"width":400,"height":320,"color":"4","type":"text","text":"# Space Complexity\nWhen an algorithm is run on a computer, it necessitates a certain amount of memory space.\n\nthe amount of memory used by a program to execute it is represented by its space complexity because a program requires memory to store input data and temporary values while running the space complexity is auxiliary and input space."},
		{"id":"d704cfefabc04a43","x":-2000,"y":960,"width":500,"height":400,"color":"4","type":"text","text":"# Time Complexity \nis defined as terms of how many times it takes to run a given algorithms based on length of the input\n\nTime complexity is a type of computational complexity that describes the time required to execute an algorithm\n\nTC(Time complexity) = C(constant) + TP(instances)\n\nfor example: S = 0; is constant\nfor(i =0; i<n;i++) is an instance of n\n\nS=s+a[i] is a constant\nfor(i=1;i<n;i*=2) is an instance of log n"},
		{"id":"431b69b56d1ce017","x":-3255,"y":890,"width":595,"height":700,"color":"4","type":"text","text":"# Arrays\n## One dimensional array\nA one dimensional array is a linear data structure that holds a fixed size sequence of elements of the same data type. it can be visualized as a single row or list of items, where each element is accessed using a unique index.\n### Example of one dimensional array\nint numbers [5] = [10,20,30,40,50];\n\n## Two dimensional array\nA two dimensional array is a collection of elements organized in a grid format, consisting of rows and columns. it can be thought of as an array of arrays, where each element is accessed using two indices, one for the row and one for the column, it is stored like a matrix\n### Example of two dimensional array\nint matrix\\[2]\\[3]= {1,2,3},{4,5,6};\n\n## Three dimensional array\nA three dimensional array extends the concept of a two dimensional array by adding another dimension allowing for the storage of data in a cube like structure, each element accessed using three indices representing the depth, row and column\n\n### Example of three dimensional array\nint cube\\[2]\\[2]\\[2] = {\n{\n{1, 2},\n{3, 4}\n},\n{\n{5, 6},\n{7, 8}\n}\n};"},
		{"id":"d01647f9088be32e","x":-3100,"y":350,"width":440,"height":400,"color":"4","type":"text","text":"# Big O\n## O(1)\nAn algorithm has a time complexity of O(1) if the execution time remains constant regardless of input size. this means that the algorithm performs a fixed number of operations\n\n## O(n)\nAn algorithm has a time complexity of O(n) if the execution time grows linearly with the input size, this means that if the input size doubles, the execution time also doubles\n\n## O(n2)\nAn algorithm has a time complexity of O(n2) if the execution time grows quadratically with the input size this is the typical for algorithms that involve nested iterations over the data set\n\n## O(n3)\nAn algorithm has a time complexity of O(n3) if the execution times grows cubically with the input size. this is common in algorithms that involve three nested iterations\n\n## O(log n)\nAn algorithm has a time complexity of O(log n) if the execution time grows logarithmic with the input size. this is typical in algorithms that involve logarithmic iterations"},
		{"id":"cbe07ce71fa5daef","x":-2880,"y":1590,"width":500,"height":860,"color":"4","type":"text","text":"# Linear and non linear data #DIFF \n\n| Points             | Linear Data Structure                                | Non Linear Data Structure                                                    |\n| ------------------ | ---------------------------------------------------- | ---------------------------------------------------------------------------- |\n| Arrangement        | Elements are arranged sequentially one after another | Elements are arranged in a hierarchical or interconnected manner             |\n| Complexity         | Easier to implement and understand                   | More complex involving intricate relationships and connections               |\n| Levels             | All elements exist at a single level                 | Elements can exist at multiple levels                                        |\n| Traversal          | Simple traversal methods                             | More complex traversal methods often requiring recursion                     |\n| Memory Utilization | Typically fixed size which may lead to wasted space  | More dynamic often utilizing memory efficiently based on relationships       |\n| Time Complexity    | Generally O(n) for basic operations                  | Varies widely can be optimized for specific operations                       |\n| Applications       | Commonly used in stacks queues and arrays            | Used in databases, ai and complex data representations like trees and graphs |\n| Examples           | Array, linked list, stack                            | Tree, graph, hash table                                                      |\n"},
		{"id":"8d5257301e7120cd","x":-890,"y":1240,"width":580,"height":460,"color":"4","type":"text","text":"# Top Down Approach\n- starts by dividing the complex algorithm into one or more modules, the process of decomposition is iterated until the desired level of modularity is achieved\n- Top-down design method is a form of stepwise refinement where we begin with the topmost module and incrementally add modules that it calls\n- the top down appraoch also known as divide and conquer, begins by viewing the problem in its entirety\n- it starts with the main problem and breaks it into smaller more manageable sub problems\n- this approach is generally associated with the use of recursion and is prevalent in design techniques like dynamic programming \n\n\n# Bottom up approach\n- the inverse of top down approach, here we start with designing the most basic of modules and then proceed towards designing higher level modules\n- the higher level modules are implemented by using the operations performed by lower level modules\n- thus, this approach sub-modules are grouped to form a higher level module, this process is repeated until the design of the complete algorithm is obtained."}
	],
	"edges":[
		{"id":"4dd9fe453bbeb664","fromNode":"f1fb50e6c00b4f01","fromSide":"right","toNode":"228fcf71a9c61079","toSide":"bottom"},
		{"id":"ca3ad7d264bd81d1","fromNode":"cbe07ce71fa5daef","fromSide":"top","toNode":"f1fb50e6c00b4f01","toSide":"bottom"},
		{"id":"fd36fe9fad1e27d9","fromNode":"d704cfefabc04a43","fromSide":"right","toNode":"f1fb50e6c00b4f01","toSide":"left"},
		{"id":"7affa14e566ce16e","fromNode":"d01647f9088be32e","fromSide":"right","toNode":"f1fb50e6c00b4f01","toSide":"top"},
		{"id":"4244b949bf4b71a0","fromNode":"f85094ec76ee6ffb","fromSide":"right","toNode":"f1fb50e6c00b4f01","toSide":"left"},
		{"id":"1ff1e3cd6cf5bf0f","fromNode":"431b69b56d1ce017","fromSide":"right","toNode":"f1fb50e6c00b4f01","toSide":"left"},
		{"id":"38f51c0eef38d04e","fromNode":"8d5257301e7120cd","fromSide":"top","toNode":"f1fb50e6c00b4f01","toSide":"bottom"}
	]
}