{
	"nodes":[
		{"id":"ae03c29d31b522d7","x":-24,"y":-173,"width":250,"height":60,"color":"5","type":"text","text":"CHAPTER 3 NOSQL AND DATABASES"},
		{"id":"8c27c9b010d0e6cd","x":458,"y":-93,"width":250,"height":60,"color":"6","type":"text","text":"CENTRAL NODE"},
		{"id":"d2d952e7015f8a0b","x":-720,"y":-203,"width":400,"height":703,"color":"5","type":"text","text":"# Document based database #EXP \n- These databases are non relational dbs instead of storing the data in rows and columns, it uses the documents to store the data in the database\n- A document database stores data in JSON BSON or XML documents\n- Documents can be stored and retrieved in a form that is much close to the data objects used in applications which means less translation is required to use data in the applications\n- Not all documents are in any collection as they require similar schema.\n---\n# Key features of database #EXP \n- Flexible schema: Documents in the dbs has a flexible schema, it means the documents in the database need not be the same schema.\n- Faster creation and maintenance: The creation of documents is easy and minimal maintance is required once it is created.\n- No foreign keys: THere is no dynamic relationship between two documents so documents can be independent of one another\n- Open formats: TO build a document we use XML, JSON and others."},
		{"id":"defa614c4f75fb67","x":-240,"y":240,"width":560,"height":760,"color":"5","type":"text","text":"# Overview of NOSQL #EXP \n- NOSQL is a type of database management system that is designed to handle and store large volumes of unstrucutred and semi strucutre data\n- unlike traditional RDBMS that use tables and pre defined schemas, NOSQL uses flexible data models that can adapt to changes in data structures and are capable of scaling horizontally to handle growing amounts of data\n- NOSQL DBs is useful in applications where there is a large amount of data to be handled\n- NOSQL DBs do not provide the same level of data consistency and transactional guarantees as traditional RDBMS, so it is not suitable for all applications\n---\n# Features of NOSQL #EXP \n- Schema flexibility: NOSQL databases often allow for dynamic schemas, meaning the structure of the data can change without needing to alter a predefined schema.\n- Scalability: Many NOSQL databases are designed to scale out hroizontally by distributing data across multiple servers. This allows them to handle large volumes of data and high velocity transactions more efficiently.\n- High Performance: NOSQL databases are optimized for performance with various data models and indexing techniques. they can handle high speed read and writes, making them suitable for real time applications\n- High Availability and fault tolerance: NOSQL databases are often designed with builtin replication and distribution features to ensure high availability and fault tolerance, this means they can continue to operate even if some parts of the system fail.\n- Eventual Consistency: unlike RDBMS that often use strong consistency models, many NOSQL dbs use eventual consistency.\n- Easy integration with big data technologies: NOSQL dbs are frequently used alongside big data technologies such as hadoop and spark. providing a robust solution for handling large scale data processing and analytics\n- Flexible QUery Languages: NOSQL dbs often come with their own query tailored to their specific data models, offering different querying capabilities compared to SQL\n---\n# Types of NOSQL dbs #EXP \n- Document based: These dbs store data as semi structured documents such as JSON or XML and can be queried using document oriented query languages eg: MongoDB, cloudant\n- Key valued store: These dbs store data as key value pairs and are optimized for simple and fast read write operations eg: Memcached, Redis\n- Column family stores: These dbs store data as column families which are sets of columns that are treated as single entity. they are optimized for fast and efficient querying of large amounts of data. eg:Hbase, Big table\n- Graph dbs: these databases store data as nodes and edges, and are designed to handle complex relationships between data. eg:  amazon neptune, neo4j\n---\n# Benefits of NOSQL dbs #EXP \n- Flexibility: NOSQL databases are designed to handle unstructured or semi structured data which means that they can accommodate dynamic changes to the data model.\n- High Availability: The auto replication feature in NOSQL dbs make them highly available because in case of any failure data replicates itself to previous consistent state\n- Scalability: NOSQL databases are highly scalable which means that they can handle large amounts of data and traffic with eaase. THis makes them a good fit for applications that need to handle large amounts of data or traffic\n- Performance: NOSQL databases are designed to handle large amounts of data and traffic which means that they can offer improved performance compared to traditional RBDMS\n- Cost effectiveness: NOSQL dbs are often more cost effective than tradtional RDBMS as they are typically less complex and do not require expensive hardware or software\n- Agikity: IDEAL for agile development."},
		{"id":"d4a21fed8bc6dd22","x":-399,"y":-1000,"width":559,"height":545,"color":"5","type":"text","text":"# Key value stores #EXP \n- a key value store is a non relational database the simplest form of a nosql database is a key value store every data element in the database is stored in key value pairs. the data can be retrieved by using a unique key allotted to each element in the database the value can be simple datatypes or complex obejcts\n- A key value store is like a reltational database with only two columns which is the key and the value\n## Key features of key value store:\n 1. Simplicity\n 2. Scalability\n 3. Speed\n ---\n# Column Oriented databases:\n- A column oriented database is a non relational database that stores the data in columns instead of rows, that means when we want to run analytics on a small number of columns you can read those columns directly without consuming memory with unwanted data\n- Columnar databases are designed to read data more efficiently and retrieve the data with greater speed. A columnar database is used to store a large amount of data\n## Key features of columnar oriented databases:\n1. Scalability \n2. Compression\n3. Very Responsive\n--- \n# Graph Based databases:\n- Graph based databases focus on the relationship between elements. it stores the data in the form of nodes in the database the connections between the nodes are called links\n## Key features of graph based databases:\n1. It is easy to identify the relationship between the data by using the links\n2. The query’s output is real time results\n3. the speed depends upon the number of relationships \n4. updating data is easy, as adding a new node or edge is a straightforward task that does not require significant schema changes"},
		{"id":"d7125c592b9a4b6c","x":-1880,"y":340,"width":674,"height":560,"color":"5","type":"text","text":"# Comparison between SQL and NOSQL #DIFF \n\n| Points:                           | SQL                            | NOSQL                                              |\n| --------------------------------- | ------------------------------ | -------------------------------------------------- |\n| USAGE                             | Used in RDBMS                  | Used in non relational or distributed dbs          |\n| Schema definition                 | Fixed or static schema         | Dynamic schema                                     |\n| Suitability for hierarchical data | Not suitable                   | Suitable                                           |\n| Suitability for queries           | Best suited for coplex queries | Not suited for complex queries but simple queiries |\n| Scalability                       | Vertically scalable            | Horizontally scalable                              |\n| Consistency protocal              | Follows ACID                   | Follows CAP                                        |\n| Examples                          | MYSQL, ORCALE DB               | MongoDB, Cassandra                                 |\n"},
		{"id":"2201cbb558fe1bcc","x":-1793,"y":-280,"width":553,"height":391,"color":"5","type":"text","text":"# MongoDB #EXP \n- Built on a scale out architecture that has become popular with devs for devloping scable applications with evolving data schemas\n- Document based database, it makes it easy for developers to store strucutred or unstructured data\n- It uses JSON or BSON file formats\n- MongoDB is an open source NOSQL dbms program\n- instead of using tables and rows as in RDBMS, MongoDB architecture is made up of collections and documents.\n--- \n# Keypoints of MONGODB documentation\n- COllection: A grouping of mongodb documents similar to a table in a relational database\n- Document: A record in MONGODB collection composed of field value pairs in BSON format\n- Schemaless: Collections do not enforce a rigid schema across all documents allowing for more flexible data models\n- BSON: MONGODB stores data in BSON format which is binary encoded JSON like documents\n---\n# CRUD in MongoDB #EXP \n- Create: To create new documents, insertOne() or insertMany() methods are used. eg: db.heet.insertOne({Name: “Heet”, Age: 30});\n- Read: to retrieve documents from mongodb, you use the find() method eg: db.heet.find({Name: “Heet”}.ToArray);\n- Update: To update existing documents in mongoDB you use updateOne() or updateMany() methods. eg: db.heet.updateOne({Name:”Heet”},{$set {age: 17}});\n- Delete: to delete documents in mongoDB, you use deleteOne() or deleteMany() methods. eg: db.heet.deleteOne({Name: “Heet”});\n---\n# Datatypes in MongoDB #EXP \n\n- String: represents text\n- integer: represents whole numbers\n- float/number: represents floating point numbers with decimal precision.\n- boolean: represents true or false values\n- date/time: represents data and time values.\n- array/list: represents an ordered collection of elements\n- Object/documents: Represents strucutred data in a key value format often similar to JSON objects.\n- BLOB: REpresents binary data.\n- UUID: Represents a unique identifier, often used for primary keys\n- Geospatial data types: Represents geographic information such as points lines or polygons\n---\n# Query through indexes in MONGODB #EXP \n- Creating an index: Index can be made using createIndex() method. eg: db.heet.createIndex({“CustomerName”: 1});\n- Querying through indexes: db.heet.find({“CustomerName”: “Heet”});\n- Checking through indexes: db.heet.find({“CustomerName”: “Heet”}).explain(“executionStats”); \n\n\n\n\n\n\n\n\n\n\n"},
		{"id":"77fefe28bcca9556","x":-2600,"y":-203,"width":640,"height":483,"color":"5","type":"file","file":"Excalidraw/Drawing 2024-10-14 07.46.03.excalidraw.md"},
		{"id":"96c406823f071266","x":-1203,"y":-650,"width":483,"height":330,"color":"5","type":"text","text":"# CRUD #EXP \n- **C**reate: This operation involves creating new records or entries in the databases\n- **R**ead: This operation involves reading or retrieving existing records from the database.\n- **U**pdate: This operation involves updating existing records in the databse.\n- **D**elete: This operation involves deleting existing records from the database\n"},
		{"id":"17c6f40eadb353bb","x":1132,"y":40,"width":386,"height":67,"color":"2","type":"text","text":"Chapter 5 Query processor and optimizer, transactions."},
		{"id":"4be52ee273a692cc","x":1104,"y":400,"width":416,"height":360,"color":"2","type":"text","text":"# Relational Algebra #EXP \n## Operations:\n- Select(alpha)\n- Project(pi)\n- Union(U)\n- Set difference(-)\n- Cartesian product(x)\n- rename(phi)\n---\n## Select(alpha)\nSelects rows from a relation that satisfy a given predicate\neg: alpha(age = 20)(Students)\n\n---\n## Project(pi)\nSelects specific columns from a relation\neg: pi(Name, Age)(Students)\n\n---\n## Union (u)\nCombines tuples from two relations, removing duplicates both relations must have the same schema\neg: Students1 U Students2\n\n---\n## Set Difference(-)\nFInds tuples that are in relation but not in the other. both relations must have the same schema.\neg: Students1 - Teachers1\n\n---\n## Cartesian Product(x)\nCombines tuples from two relations to form a new relation with all possible pairs of tuples\neg: Courses x Professors\n\n---\nRename(phi)\nRenames the attributes of a relation\neg: pi(Pupils(ID,FullName,Age)(Students))"},
		{"id":"527b94f3f2628435","x":1651,"y":341,"width":689,"height":279,"color":"2","type":"text","text":"# Transactions\n## Concept\n- A transaction in a database is a sequence of operations performed as a single logical unit of work.\n- A transaction ensures that the database moves from one consistent state to another.\n- Transactions are fundamental to maintaining the integrity and consistency of data in databases.\n---\n## ACID\n- Atomicity: The entire transaction is treated as a single unit either all operations in the transaction are completed or none are.\n- Consistency: A transaction takes the database from one consistent state to another. it ensures that any changes amde by a transaction are valid according to the predefined rules, constraints and triggers.\n- Isolation: Transactions are executed in isolation from eachother, ensuring that immediate results of a transaction are not visible to other concurrent transactions. this prevents conflict between multiple transactions.\n- Durability: Once a transaction is committed the changes it made are permanent even in the event of a system crash. the system ensures that the results are not lost.\n---\n## Operations of a transaction:\n- Read-only: These only retrieve data from the database.\n- Write: These modify the data in the database.\n---\n"},
		{"id":"e4ad3b8106dee087","x":2340,"y":-293,"width":460,"height":453,"color":"2","type":"file","file":"Excalidraw/Drawing 2024-10-14 08.54.11.excalidraw.md"},
		{"id":"1d326e149ce6eaf7","x":1651,"y":-293,"width":430,"height":229,"color":"2","type":"text","text":"# Transactional Model #EXP \n- Active: The transaction is currently executing.\n- Partially committed: The final operation has been executed but changes are not yet permnanet.\n- Committed: All operations of the transaction have been completed and changes are saved.\n- Filed: THe transaction encountered an error or failure.\n- ABorted: Ater a failure the transaction and database are rolled back to previous state before the transaction began"},
		{"id":"28c40ac72f43fb40","x":2513,"y":449,"width":487,"height":351,"color":"2","type":"text","text":"# Serializability #EXP \nEnsures that even if transaction are executed concurrently the final result is correct and consistent, as if they were executed in isolation\n\n---\n\n| T1       | T2        |\n| -------- | --------- |\n| Read(x)  |           |\n| Write(x) |           |\n|          | Read(x)   |\n|          | Write (x) |\n|          |           |\n1. Initial state: T1 begns by reading the values of X then writing to X after T1 is done, t2 starts and reads the updates value of X and writes to X.\n2. T1 writes to X before T2 reads X since both T1 and T2 are accessing the same data item with at least one write operation these operations conflict.\n3. This schedule is serializable because the outcome is the same as the following serial schedule, first t1 completes its operations only then is t2 allowed to do its operations.\n---\n## Types of serialization \n- Conflict Serializability: Two schedules are conflict equivalent if they involve the same set of transactions and operations, conflicting operatons are in the same order.\n- Serial Schedule: We can rearrange the schedule by swapping non conflicting operations  and we can transform this schedule into a serial schedule.\n- VIew Serializability: The transactions in both schedules read the same initial values, if a transaction in one schedule reads a value written by another transaction, the same holds true in the other schedule. the final write operations in both schedules are the same. this is said to be view equivalent.\n---\n\n|     |     |     |\n| --- | --- | --- |\n## Serial vs NOn serial schedule:\n### Serial\nTransaction are executed one after the other with no overlap.\n### Non serial\nTransaction are executed interleaved.\n"},
		{"id":"d09a2559b296845c","x":1839,"y":873,"width":561,"height":247,"color":"2","type":"text","text":"# Procedural Graph #EXP \nA common way to check for conflict serializability is to construct a precednce graph.\n- Nodes represents transactions\n- Edges represent conflicts between transactions, meaning one transactions must occur before another for consistency."},
		{"id":"b99ec5a9ffd4721e","x":720,"y":-640,"width":320,"height":80,"color":"3","type":"text","text":"Chapter 6: Concurrency control and recovery system."},
		{"id":"b51079cb7a06b4a9","x":520,"y":-1240,"width":440,"height":320,"color":"3","type":"text","text":"# Compatibility function #EXP \n- In the context of database management system, a compatibility function is a mechanism used primarily in concurrency control to determine whther a set of operations can safely occur simultaneously without violating data integrity or concistency.\n- The compatibility function in DBMS plays a crucial role in managing how transaction interact with each other through locks.\n- By defining which locks types can coexist, it helps maintain data integrity supports concurrency control and aids in deadlock prevention\n---\n# Use of compatibility:\n- Determining lock status: The compatibility function helps determine if a new lock request can be granted based on existing locks held by other transactions\n- Concurrency Control: By ensuring that only compatible with existing locks, it can be granted, otherwise, the requesting transaction must wait.\n- Deadlock prevention: Compatibility functions can also play a role in deadlock detection and prevention by managing lock acquisition strategies and ensuring that trasnactions do not enter a state where they are waiting on eachother\n---\n### Dirty read:\nA dirty read occurs when a transaction reads data that has been modified by another ongoing transaction that hs not yet been committted.\n\n---\n## 2-phase locking\n\n### Growing phase: \nin this phase, a transaction can acquire any number of locks. however it cannot release any locks.\n### Shrinking phase:\nonce the transaction releases it first lock, it enters this.\nthis phase, the transaction can release locks but cannot acquire new locks.\nthis transaction continues to release locks until it completes."},
		{"id":"d3ca2bfae8eb5ac7","x":1248,"y":-1198,"width":403,"height":358,"color":"3","type":"text","text":"# locking mechanism #exp \n- DBMS often sue locks to manage concurrent access to data, locks can be exclusive or shared.\n---\n## Compatibility of locks:\nThe compatibility functions defines which types of lock can coexist: \neg: shared lock (s): allows multiple transactions to read the data but no modify it.\nexclusive(x): allows a single transaction to both read and modify the data.\n\n\n---\n\n## Compatibility Matrix\n\n\n|     | S   | X   |\n| --- | --- | --- |\n| S   | T   | F   |\n| X   | F   | F   |\n\n---\n\n\n\n\n"},
		{"id":"397e2268a4b16832","x":1325,"y":-630,"width":435,"height":230,"color":"3","type":"text","text":"# Starvation\n- in RDBMS, starvation refers to a situation where a partocilar transaction is perpetually delayed or never gets access to the resource it needs to proceed even though the resources are available.\n- this usually happens due to poor scheduling polcies.\n---\n## Causes of starvation\n- Priority Scheduling: If dbms uses a priority based scheduling algorithm, lower priority transactions may be indefinitely postponed because higher priority transactions keep getting access to resources.\n- frequent rollback due to deadlock \n- LOnger transactions\n---\n# SOlutions:\n- Fair scheduling\n- AGing\n- deadlock detection and resolution\n"}
	],
	"edges":[
		{"id":"9a6e0cdf02c4fafe","fromNode":"defa614c4f75fb67","fromSide":"top","toNode":"ae03c29d31b522d7","toSide":"bottom"},
		{"id":"428c698df80ab5df","fromNode":"ae03c29d31b522d7","fromSide":"right","toNode":"8c27c9b010d0e6cd","toSide":"left"},
		{"id":"28873fd53a9eb22e","fromNode":"d2d952e7015f8a0b","fromSide":"right","toNode":"ae03c29d31b522d7","toSide":"left"},
		{"id":"0132a628ec3d874e","fromNode":"d4a21fed8bc6dd22","fromSide":"bottom","toNode":"ae03c29d31b522d7","toSide":"top"},
		{"id":"8a4b4ddb2ef52ebf","fromNode":"d7125c592b9a4b6c","fromSide":"right","toNode":"d2d952e7015f8a0b","toSide":"left"},
		{"id":"d163845d134cc763","fromNode":"d7125c592b9a4b6c","fromSide":"right","toNode":"defa614c4f75fb67","toSide":"left"},
		{"id":"6d893741f43547f8","fromNode":"77fefe28bcca9556","fromSide":"right","toNode":"2201cbb558fe1bcc","toSide":"left"},
		{"id":"7507d34cd6e396ca","fromNode":"96c406823f071266","fromSide":"right","toNode":"ae03c29d31b522d7","toSide":"left"},
		{"id":"fdf8188b300e7172","fromNode":"2201cbb558fe1bcc","fromSide":"top","toNode":"96c406823f071266","toSide":"left"},
		{"id":"2c7959999e1c3186","fromNode":"2201cbb558fe1bcc","fromSide":"right","toNode":"d2d952e7015f8a0b","toSide":"top"},
		{"id":"6e16762400ed562d","fromNode":"4be52ee273a692cc","fromSide":"top","toNode":"17c6f40eadb353bb","toSide":"bottom"},
		{"id":"60ff3223f0f1dd48","fromNode":"17c6f40eadb353bb","fromSide":"top","toNode":"8c27c9b010d0e6cd","toSide":"right"},
		{"id":"12bf8446c80161b8","fromNode":"527b94f3f2628435","fromSide":"top","toNode":"17c6f40eadb353bb","toSide":"right"},
		{"id":"701fb05be2fcea39","fromNode":"1d326e149ce6eaf7","fromSide":"left","toNode":"17c6f40eadb353bb","toSide":"right"},
		{"id":"4d3664d12962e664","fromNode":"e4ad3b8106dee087","fromSide":"left","toNode":"1d326e149ce6eaf7","toSide":"right"},
		{"id":"48128d1dd3c6696f","fromNode":"28c40ac72f43fb40","fromSide":"left","toNode":"527b94f3f2628435","toSide":"right"},
		{"id":"f0f4309c421d2011","fromNode":"d09a2559b296845c","fromSide":"top","toNode":"28c40ac72f43fb40","toSide":"bottom"},
		{"id":"dcdc77ff9352c8b7","fromNode":"b99ec5a9ffd4721e","fromSide":"bottom","toNode":"8c27c9b010d0e6cd","toSide":"top"},
		{"id":"81632294d4832b14","fromNode":"b51079cb7a06b4a9","fromSide":"bottom","toNode":"b99ec5a9ffd4721e","toSide":"top"},
		{"id":"ef8e6aa5bf10f5f6","fromNode":"d3ca2bfae8eb5ac7","fromSide":"left","toNode":"b99ec5a9ffd4721e","toSide":"right"},
		{"id":"428acd83d11ac2a2","fromNode":"397e2268a4b16832","fromSide":"left","toNode":"b99ec5a9ffd4721e","toSide":"bottom"}
	]
}